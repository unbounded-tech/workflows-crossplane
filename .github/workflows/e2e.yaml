name: e2e

on:
  workflow_call:
    inputs:
      ghcr_user:
        description: 'ghcr user'
        required: false
        type: string

      crossplane_version:
        description: 'Crossplane CLI version to install'
        required: false
        type: string
        default: 'v2.0.2'

      pattern:
        description: 'Test file pattern'
        required: false
        type: string
        default: 'tests/e2e*'

      timeout-minutes:
        description: 'Timeout in minutes for the e2e test step'
        required: false
        type: number
        default: 20

      cleanup-timeout-minutes:
        description: 'Timeout in minutes for the cleanup step'
        required: false
        type: number
        default: 10

      aws:
        description: 'Enable AWS credentials setup'
        required: false
        type: boolean
        default: false

      debug-example-path:
        description: 'Path to example YAML file to auto-discover root resource type for debugging'
        required: false
        type: string

      debug-resource-types:
        description: 'Comma-separated list of additional resource types to debug (format: kind.apiVersion, e.g., IdentityCenter.aws.platform.upbound.io)'
        required: false
        type: string

    secrets:
      GH_PAT:
        description: 'Token for ghcr.io package write access'
        required: false

      AWS_ACCESS_KEY_ID:
        description: 'AWS Access Key ID for E2E tests'
        required: false

      AWS_SECRET_ACCESS_KEY:
        description: 'AWS Secret Access Key for E2E tests'
        required: false

      AWS_SESSION_TOKEN:
        description: 'AWS Session Token for E2E tests (required for OIDC/assumed roles)'
        required: false

permissions:
  contents: read
  packages: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Cache upbound + crossplane
        uses: actions/cache@v4
        with:
          path: |
            ~/.crossplane/cache
            ~/.up/cache
          key: ${{ runner.os }}-crossplane-${{ hashFiles('**/upbound.yaml','**/definition.yaml') }}-

      - name: Install & login with up
        uses: upbound/action-up@v1.0.0
        with:
          skip-login: true

      - name: Install Crossplane CLI
        run: |
          curl -sL https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh \
            | XP_VERSION=${{ inputs.crossplane_version }} sh

      - name: check for GH_PAT if ghcr_user is set
        if: inputs.ghcr_user
        run: |
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "GH_PAT secret must be set if ghcr_user is set"
            exit 1
          fi

      - name: Docker login to GHCR
        if: inputs.ghcr_user
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ inputs.ghcr_user }}
          password: ${{ secrets.GH_PAT }}

      - name: Docker login to GHCR
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build with up
        uses: upbound/action-up-project@v1.1.2
        with:
          skip-login-check: true

      - name: Create AWS Credentials
        if: inputs.aws
        run: |
          mkdir -p ~/.aws
          echo "[default]" > ~/.aws/credentials
          echo "aws_access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}" >> ~/.aws/credentials
          echo "aws_secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> ~/.aws/credentials
          if [ -n "${{ secrets.AWS_SESSION_TOKEN }}" ]; then
            echo "aws_session_token = ${{ secrets.AWS_SESSION_TOKEN }}" >> ~/.aws/credentials
          fi

          for dir in ${{ inputs.pattern }}; do
            if [ -d "$dir" ]; then
              mkdir -p "$dir/secrets"
              cp ~/.aws/credentials "$dir/secrets/aws-creds"
            fi
          done

      # - name: Create ENV secrets
      #   run: |
      #     for dir in ${{ inputs.pattern }}; do
      #       if [ -d "$dir" ]; then
      #         mkdir -p "$dir/secrets/env"
      #         env | while IFS='=' read -r name value; do
      #           if [ -n "$name" ]; then
      #             echo "$value" > "$dir/secrets/env/$name"
      #           fi
      #         done
      #       fi
      #     done

      - name: Test
        id: test
        timeout-minutes: ${{ inputs.timeout-minutes }}
        run: |
          up test run ${{ inputs.pattern }} --e2e --skip-control-plane-cleanup

      - name: Debug failed resources
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping debug output"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== All Managed Resources ==="
          kubectl get managed -n default
          echo ""
          echo "=== Resources with False conditions ==="
          kubectl get managed -n default | grep False | awk '{print $1}' | while read -r resource; do
            if [ -n "$resource" ]; then
              echo ""
              echo "=== $resource YAML ==="
              kubectl get "$resource" -o yaml || true
              echo ""
              echo "=== $resource Describe ==="
              kubectl describe "$resource" || true
            fi
          done

      - name: Force delete managed resources
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping force delete"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Deleting all managed resources ==="
          kubectl get managed -n default --no-headers | awk '{print $1}' | while read -r resource; do
            if [ -n "$resource" ]; then
              echo "Deleting $resource"
              kubectl delete "$resource" --wait=false || true
            fi
          done

      - name: Wait for cleanup
        if: always()
        run: |
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          kubectl get managed -n default
          kubectl wait --for=delete --timeout=${{ inputs.cleanup-timeout-minutes }}m -n default --all managed
