name: e2e

on:
  workflow_call:
    inputs:
      ghcr-user:
        description: 'ghcr user'
        required: false
        type: string

      crossplane_version:
        description: 'Crossplane CLI version to install'
        required: false
        type: string
        default: 'v2.0.2'

      pattern:
        description: 'Test file pattern'
        required: false
        type: string
        default: 'tests/e2e*'

      timeout-minutes:
        description: 'Timeout in minutes for the e2e test step'
        required: false
        type: number
        default: 20

      cleanup-timeout-minutes:
        description: 'Timeout in minutes for the cleanup step'
        required: false
        type: number
        default: 10

      aws:
        description: 'Enable AWS credentials setup'
        required: false
        type: boolean
        default: false

      aws-use-oidc:
        description: 'Use GitHub OIDC to assume an AWS role'
        required: false
        type: boolean
        default: false

      aws-role-name:
        description: 'AWS IAM role name to assume via OIDC'
        required: false
        type: string
        default: 'hops-github-actions'

      aws-role-arn:
        description: 'AWS IAM role ARN to assume via OIDC (overrides aws-role-name + aws-account-id)'
        required: false
        type: string

      aws-account-id:
        description: 'AWS account ID used to build role ARN when aws-role-arn is not provided'
        required: false
        type: string

      aws-region:
        description: 'AWS region for OIDC credential configuration'
        required: false
        type: string
        default: 'us-east-1'

      debug-resource-types:
        description: 'JSON array of resource types to print debug information for when tests fail (e.g., ["IdentityCenter.aws.platform.upbound.io", "Organization.aws.platform.upbound.io"])'
        required: false
        type: string

      debug-get-yaml:
        description: 'Show kubectl get -o yaml output for failed resources'
        required: false
        type: boolean
        default: false

      debug-describe:
        description: 'Show kubectl describe output for failed resources'
        required: false
        type: boolean
        default: true

      debug-usages:
        description: 'Show kubectl get usages output for debugging'
        required: false
        type: boolean
        default: true

      namespace:
        description: 'Kubernetes namespace for test resources'
        required: false
        type: string
        default: 'default'

      debug:
        description: 'Enable debug output for up test command'
        required: false
        type: boolean
        default: false

    secrets:
      GH_PAT:
        description: 'Token for ghcr.io package write access'
        required: false

      AWS_ACCESS_KEY_ID:
        description: 'AWS Access Key ID for E2E tests'
        required: false

      AWS_SECRET_ACCESS_KEY:
        description: 'AWS Secret Access Key for E2E tests'
        required: false

      AWS_SESSION_TOKEN:
        description: 'AWS Session Token for E2E tests (required for OIDC/assumed roles)'
        required: false

permissions:
  contents: read
  packages: read
  id-token: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Cache upbound + crossplane
        uses: actions/cache@v5
        with:
          path: |
            ~/.crossplane/cache
            ~/.up/cache
          key: ${{ runner.os }}-crossplane-${{ hashFiles('**/upbound.yaml','**/definition.yaml') }}-

      - name: Install & login with up
        uses: upbound/action-up@v1.0.0
        with:
          skip-login: true

      - name: Install Crossplane CLI
        run: |
          curl -sL https://raw.githubusercontent.com/crossplane/crossplane/master/install.sh \
            | XP_VERSION=${{ inputs.crossplane_version }} sh

      - name: check for GH_PAT if ghcr-user is set
        if: inputs.ghcr-user
        run: |
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "GH_PAT secret must be set if ghcr-user is set"
            exit 1
          fi

      - name: Docker login to GHCR
        if: inputs.ghcr-user
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ inputs.ghcr-user }}
          password: ${{ secrets.GH_PAT }}

      - name: Docker login to GHCR
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ github.token }}

      - name: Build with up
        uses: upbound/action-up-project@v1.1.2
        with:
          skip-login-check: true

      - name: Check for AWS credentials if aws is enabled
        if: inputs.aws
        run: |
          if [ "${{ inputs.aws-use-oidc }}" = "true" ]; then
            if [ -z "${{ inputs.aws-role-arn }}" ] && [ -z "${{ inputs.aws-account-id }}" ]; then
              echo "aws-role-arn or aws-account-id must be set when aws-use-oidc is true"
              exit 1
            fi
          else
            if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then
              echo "AWS_ACCESS_KEY_ID secret must be set if aws is enabled"
              exit 1
            fi
            if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then
              echo "AWS_SECRET_ACCESS_KEY secret must be set if aws is enabled"
              exit 1
            fi
          fi

      - name: Configure AWS Credentials (OIDC)
        if: inputs.aws && inputs.aws-use-oidc
        id: aws-oidc-creds
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ inputs.aws-role-arn || format('arn:aws:iam::{0}:role/{1}', inputs.aws-account-id, inputs.aws-role-name) }}
          aws-region: ${{ inputs.aws-region }}
          output-credentials: true

      - name: Create AWS Credentials
        if: inputs.aws
        run: |
          mkdir -p ~/.aws
          echo "[default]" > ~/.aws/credentials
          if [ "${{ inputs.aws-use-oidc }}" = "true" ]; then
            echo "aws_access_key_id = ${{ steps.aws-oidc-creds.outputs.aws-access-key-id }}" >> ~/.aws/credentials
            echo "aws_secret_access_key = ${{ steps.aws-oidc-creds.outputs.aws-secret-access-key }}" >> ~/.aws/credentials
            echo "aws_session_token = ${{ steps.aws-oidc-creds.outputs.aws-session-token }}" >> ~/.aws/credentials
          else
            echo "aws_access_key_id = ${{ secrets.AWS_ACCESS_KEY_ID }}" >> ~/.aws/credentials
            echo "aws_secret_access_key = ${{ secrets.AWS_SECRET_ACCESS_KEY }}" >> ~/.aws/credentials
            if [ -n "${{ secrets.AWS_SESSION_TOKEN }}" ]; then
              echo "aws_session_token = ${{ secrets.AWS_SESSION_TOKEN }}" >> ~/.aws/credentials
            fi
          fi

          for dir in ${{ inputs.pattern }}; do
            if [ -d "$dir" ]; then
              mkdir -p "$dir/secrets"
              cp ~/.aws/credentials "$dir/secrets/aws-creds"
            fi
          done

      # - name: Create ENV secrets
      #   run: |
      #     for dir in ${{ inputs.pattern }}; do
      #       if [ -d "$dir" ]; then
      #         mkdir -p "$dir/secrets/env"
      #         env | while IFS='=' read -r name value; do
      #           if [ -n "$name" ]; then
      #             echo "$value" > "$dir/secrets/env/$name"
      #           fi
      #         done
      #       fi
      #     done

      - name: Test
        id: test
        timeout-minutes: ${{ inputs.timeout-minutes }}
        run: |
          up test run ${{ inputs.pattern }} --e2e --skip-control-plane-cleanup ${{ inputs.debug && '--debug' || '' }}

      - name: (Debug) Set debug resource types
        if: always()
        run: |
          ROOT_RESOURCE_TYPE=""
          DEBUG_TYPES=""

          # Auto-discover root resource types from apis/**/definition.yaml files
          for def_file in apis/*/definition.yaml; do
            if [ -f "$def_file" ]; then
              # Extract metadata.name which contains the full resource type (e.g., identitycenters.aws.hops.ops.com.ai)
              DEF_NAME=$(yq '.metadata.name' "$def_file")
              if [ -n "$DEF_NAME" ] && [ "$DEF_NAME" != "null" ]; then
                echo "Discovered resource type from $def_file: $DEF_NAME"
                if [ -z "$ROOT_RESOURCE_TYPE" ]; then
                  ROOT_RESOURCE_TYPE="$DEF_NAME"
                fi
                if [ -z "$DEBUG_TYPES" ]; then
                  DEBUG_TYPES="$DEF_NAME"
                else
                  DEBUG_TYPES="${DEBUG_TYPES},${DEF_NAME}"
                fi
              fi
            fi
          done

          # Add user-provided debug resource types (expects JSON array)
          USER_TYPES='${{ inputs.debug-resource-types }}'
          if [ -n "$USER_TYPES" ]; then
            # Parse JSON array and convert to comma-separated string
            PARSED_TYPES=$(echo "$USER_TYPES" | jq -r 'if type == "array" then .[] else empty end' 2>/dev/null | paste -sd,)
            if [ -n "$PARSED_TYPES" ]; then
              # If no root resource type discovered from example, use first from debug-resource-types
              if [ -z "$ROOT_RESOURCE_TYPE" ]; then
                ROOT_RESOURCE_TYPE=$(echo "$PARSED_TYPES" | cut -d',' -f1)
                echo "Using first debug resource type as root: $ROOT_RESOURCE_TYPE"
              fi
              if [ -n "$DEBUG_TYPES" ]; then
                DEBUG_TYPES="${DEBUG_TYPES},${PARSED_TYPES}"
              else
                DEBUG_TYPES="$PARSED_TYPES"
              fi
            fi
          fi

          echo "ROOT_RESOURCE_TYPE=$ROOT_RESOURCE_TYPE" >> "$GITHUB_ENV"
          echo "DEBUG_TYPES=$DEBUG_TYPES" >> "$GITHUB_ENV"
          echo "Debug resource types: $DEBUG_TYPES"

      - name: (Debug) Log namespace events
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping debug output"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Namespace Events ==="
          kubectl get events -n ${{ inputs.namespace }} --sort-by='.lastTimestamp'

      - name: (Debug) Logs For Managed Resources
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping debug output"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== All Managed Resources ==="
          kubectl get managed -n ${{ inputs.namespace }}
          echo ""
          echo "=== Resources with False or Unknown (-) conditions ==="
          kubectl get managed -n ${{ inputs.namespace }} | awk 'NR>1 && ($2 == "False" || $2 == "-" || $3 == "False" || $3 == "-") {print $1}' | while read -r resource; do
            if [ -n "$resource" ]; then
              if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                echo ""
                echo "=== $resource YAML ==="
                kubectl get "$resource" -n ${{ inputs.namespace }} -o yaml || true
              fi
              if [ "${{ inputs.debug-describe }}" = "true" ]; then
                echo ""
                echo "=== $resource Describe ==="
                kubectl describe "$resource" -n ${{ inputs.namespace }} || true
              fi
            fi
          done

      - name: (Debug) Logs For Usages
        if: always() && inputs.debug-usages
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping debug output"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Usages ==="
          kubectl get usages -n ${{ inputs.namespace }} || true
          echo ""
          echo "=== Debugging usages ==="
          kubectl get usages -n ${{ inputs.namespace }} --no-headers 2>/dev/null | awk '{print $1}' | while read -r usage; do
            if [ -n "$usage" ]; then
              if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                echo ""
                echo "=== usage/$usage YAML ==="
                kubectl get usage "$usage" -n ${{ inputs.namespace }} -o yaml || true
              fi
              if [ "${{ inputs.debug-describe }}" = "true" ]; then
                echo ""
                echo "=== usage/$usage Describe ==="
                kubectl describe usage "$usage" -n ${{ inputs.namespace }} || true
              fi
            fi
          done

      - name: (Debug) Logs For Composite Resources
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping debug output"
            exit 0
          fi
          if [ -z "$DEBUG_TYPES" ]; then
            echo "No debug resource types configured, skipping"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Debugging composite resources ==="
          echo "$DEBUG_TYPES" | tr ',' '\n' | while read -r resource_type; do
            if [ -n "$resource_type" ]; then
              echo ""
              echo "=== Checking $resource_type ==="
              if kubectl get "$resource_type" -n ${{ inputs.namespace }} --no-headers 2>/dev/null | head -n1 | grep -q .; then
                kubectl get "$resource_type" -n ${{ inputs.namespace }} --no-headers | awk '{print $1}' | while read -r name; do
                  if [ -n "$name" ]; then
                    if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                      echo ""
                      echo "=== $resource_type/$name YAML ==="
                      kubectl get "$resource_type" "$name" -n ${{ inputs.namespace }} -o yaml || true
                    fi
                    if [ "${{ inputs.debug-describe }}" = "true" ]; then
                      echo ""
                      echo "=== $resource_type/$name Describe ==="
                      kubectl describe "$resource_type" "$name" -n ${{ inputs.namespace }} || true
                    fi
                  fi
                done
              else
                echo "No $resource_type resources found"
              fi
            fi
          done

      - name: (Debug) Delete Test Resources
        if: always()
        run: |
          if [ "${{ steps.test.outcome }}" = "success" ]; then
            echo "Test passed, skipping delete - when tests pass, resources should be cleaned up normally"
            exit 0
          fi
          if [ -z "$ROOT_RESOURCE_TYPE" ]; then
            echo "No root resource type discovered, skipping"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"

          # Delete root composite resource (cascade will delete children)
          echo "=== Deleting root resource ($ROOT_RESOURCE_TYPE) ==="
          kubectl get "$ROOT_RESOURCE_TYPE" -n ${{ inputs.namespace }} --no-headers 2>/dev/null | awk '{print $1}' | while read -r name; do
            if [ -n "$name" ]; then
              echo "Deleting $ROOT_RESOURCE_TYPE/$name"
              kubectl delete "$ROOT_RESOURCE_TYPE" "$name" -n ${{ inputs.namespace }} || true
            fi
          done

      - name: Wait for cleanup
        id: cleanup
        if: always()
        run: |
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          kubectl get managed -n ${{ inputs.namespace }}
          kubectl wait --for=delete --timeout=${{ inputs.cleanup-timeout-minutes }}m -n ${{ inputs.namespace }} --all managed

      - name: (Debug) Log Remaining Managed Resources
        if: always() && steps.cleanup.outcome != 'success'
        run: |
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Cleanup failed - listing remaining managed resources ==="
          kubectl get managed -n ${{ inputs.namespace }}
          echo ""
          echo "=== Debugging all remaining resources ==="
          kubectl get managed -n ${{ inputs.namespace }} --no-headers 2>/dev/null | awk '{print $1}' | while read -r resource; do
            if [ -n "$resource" ]; then
              if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                echo ""
                echo "=== $resource YAML ==="
                kubectl get "$resource" -n ${{ inputs.namespace }} -o yaml || true
              fi
              if [ "${{ inputs.debug-describe }}" = "true" ]; then
                echo ""
                echo "=== $resource Describe ==="
                kubectl describe "$resource" -n ${{ inputs.namespace }} || true
              fi
            fi
          done

      - name: (Debug) Log Remaining Usages
        if: always() && steps.cleanup.outcome != 'success' && inputs.debug-usages
        run: |
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Usages ==="
          kubectl get usages -n ${{ inputs.namespace }} || true
          echo ""
          echo "=== Debugging usages ==="
          kubectl get usages -n ${{ inputs.namespace }} --no-headers 2>/dev/null | awk '{print $1}' | while read -r usage; do
            if [ -n "$usage" ]; then
              if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                echo ""
                echo "=== usage/$usage YAML ==="
                kubectl get usage "$usage" -n ${{ inputs.namespace }} -o yaml || true
              fi
              if [ "${{ inputs.debug-describe }}" = "true" ]; then
                echo ""
                echo "=== usage/$usage Describe ==="
                kubectl describe usage "$usage" -n ${{ inputs.namespace }} || true
              fi
            fi
          done

      - name: (Debug) Log Remaining Composite Resources
        if: always() && steps.cleanup.outcome != 'success'
        run: |
          if [ -z "$DEBUG_TYPES" ]; then
            echo "No debug resource types configured, skipping"
            exit 0
          fi
          CLUSTER_NAME=$(kind get clusters | head -n1)
          kind export kubeconfig --name "$CLUSTER_NAME"
          echo "=== Debugging composite resources ==="
          echo "$DEBUG_TYPES" | tr ',' '\n' | while read -r resource_type; do
            if [ -n "$resource_type" ]; then
              echo ""
              echo "=== Checking $resource_type ==="
              if kubectl get "$resource_type" -n ${{ inputs.namespace }} --no-headers 2>/dev/null | head -n1 | grep -q .; then
                kubectl get "$resource_type" -n ${{ inputs.namespace }} --no-headers | awk '{print $1}' | while read -r name; do
                  if [ -n "$name" ]; then
                    if [ "${{ inputs.debug-get-yaml }}" = "true" ]; then
                      echo ""
                      echo "=== $resource_type/$name YAML ==="
                      kubectl get "$resource_type" "$name" -n ${{ inputs.namespace }} -o yaml || true
                    fi
                    if [ "${{ inputs.debug-describe }}" = "true" ]; then
                      echo ""
                      echo "=== $resource_type/$name Describe ==="
                      kubectl describe "$resource_type" "$name" -n ${{ inputs.namespace }} || true
                    fi
                  fi
                done
              else
                echo "No $resource_type resources found"
              fi
            fi
          done
