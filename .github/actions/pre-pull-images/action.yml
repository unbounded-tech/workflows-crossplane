name: 'Pre-pull OCI Images'
description: 'Pre-pull Docker and OCI images used by Crossplane/Upbound tooling with caching'

inputs:
  kind-node:
    description: 'Pull kindest/node image for Kind clusters'
    required: false
    default: 'false'
  kind-node-version:
    description: 'Kind node version to pull'
    required: false
    default: 'v1.33.1'
  upbound-images:
    description: 'Pull internal Upbound CLI images (olareg, datamodel-code-generator, kcl, function-go-templating-base)'
    required: false
    default: 'true'
  from-upbound-yaml:
    description: 'Pull functions/providers/configurations from upbound.yaml'
    required: false
    default: 'true'
  extra-docker-images:
    description: 'Comma-separated list of additional Docker images to pull'
    required: false
    default: ''
  extra-oci-images:
    description: 'Comma-separated list of additional OCI images to pull with crane'
    required: false
    default: ''
  cache-key-prefix:
    description: 'Prefix for cache key (allows different caches per workflow)'
    required: false
    default: 'oci-images'

outputs:
  cache-hit:
    description: 'Whether the cache was hit'
    value: ${{ steps.cache.outputs.cache-hit }}
  cache-path:
    description: 'Path to the OCI cache directory'
    value: ${{ steps.setup.outputs.cache-path }}

runs:
  using: 'composite'
  steps:
    - name: Setup cache directory
      id: setup
      shell: bash
      run: |
        CACHE_DIR="$HOME/.oci-cache"
        mkdir -p "$CACHE_DIR"
        echo "cache-path=$CACHE_DIR" >> $GITHUB_OUTPUT

        # Generate cache key from upbound.yaml if it exists
        if [ -f upbound.yaml ]; then
          HASH=$(sha256sum upbound.yaml | cut -d' ' -f1 | head -c 16)
        else
          HASH="no-upbound-yaml"
        fi
        echo "hash=$HASH" >> $GITHUB_OUTPUT

    - name: Restore OCI cache
      id: cache
      uses: actions/cache@v4
      with:
        path: ${{ steps.setup.outputs.cache-path }}
        key: ${{ inputs.cache-key-prefix }}-${{ runner.os }}-${{ steps.setup.outputs.hash }}
        restore-keys: |
          ${{ inputs.cache-key-prefix }}-${{ runner.os }}-

    - name: Install crane
      shell: bash
      run: |
        if ! command -v crane &> /dev/null; then
          CRANE_VERSION="v0.20.2"
          curl -sL "https://github.com/google/go-containerregistry/releases/download/${CRANE_VERSION}/go-containerregistry_Linux_x86_64.tar.gz" | tar -xzf - crane
          sudo mv crane /usr/local/bin/
        fi

    - name: Pre-pull images
      shell: bash
      env:
        CACHE_DIR: ${{ steps.setup.outputs.cache-path }}
      run: |
        set -euo pipefail

        # Error handler
        error_handler() {
          local line=$1
          local cmd=$2
          echo ""
          echo "ERROR: Command failed at line $line: $cmd"
          echo ""
        }
        trap 'error_handler ${LINENO} "$BASH_COMMAND"' ERR

        echo "Pre-pulling Docker/OCI images in parallel..."
        echo "Cache directory: $CACHE_DIR"

        # Create temp directory for logs
        LOGDIR=$(mktemp -d)

        # Track PIDs and their descriptions
        declare -A PIDS

        # Helper function to pull OCI image with caching
        pull_oci_image() {
          local img="$1"
          local logfile="$2"
          local cache_file="$CACHE_DIR/$(echo "$img" | sed 's|/|_|g; s/:/_/g').tar"

          # Check if already cached
          if [ -f "$cache_file" ]; then
            echo "Cache hit: $img" > "$logfile"
            echo "Cached at: $cache_file" >> "$logfile"
            # Verify the cached image is still valid
            if crane digest "$img" >> "$logfile" 2>&1; then
              echo "Verified: $img" >> "$logfile"
              return 0
            else
              echo "Cache stale, re-pulling..." >> "$logfile"
              rm -f "$cache_file"
            fi
          fi

          # Pull the image
          echo "Pulling: $img" >> "$logfile"
          if crane digest "$img" >> "$logfile" 2>&1; then
            if crane pull "$img" "$cache_file" >> "$logfile" 2>&1; then
              echo "Cached to: $cache_file" >> "$logfile"
              echo "Verified: $img" >> "$logfile"
              return 0
            fi
          fi
          return 1
        }
        export -f pull_oci_image
        export CACHE_DIR

        # Kind node (Docker image)
        if [ "${{ inputs.kind-node }}" = "true" ]; then
          docker pull kindest/node:${{ inputs.kind-node-version }} > "$LOGDIR/docker-kindest-node.log" 2>&1 &
          PIDS[$!]="docker-kindest-node"
        fi

        # Extra Docker images
        if [ -n "${{ inputs.extra-docker-images }}" ]; then
          while read img; do
            img=$(echo "$img" | xargs)  # trim whitespace
            if [ -n "$img" ]; then
              name=$(echo "$img" | sed 's|.*/||' | sed 's/:/-/g')
              docker pull "$img" > "$LOGDIR/docker-$name.log" 2>&1 &
              PIDS[$!]="docker-$name"
            fi
          done < <(echo "${{ inputs.extra-docker-images }}" | tr ',' '\n')
        fi

        # Upbound internal images used by `up` CLI (from xpkg.upbound.io)
        # Dynamically look up latest versions
        if [ "${{ inputs.upbound-images }}" = "true" ]; then
          for img in olareg datamodel-code-generator kcl function-go-templating-base; do
            (
              base="xpkg.upbound.io/upbound/$img"
              logfile="$LOGDIR/upbound-$img.log"

              # Get all semver tags sorted
              all_tags=$(crane ls "$base" 2>/dev/null | grep -E '^v[0-9]' | sort -V)
              if [ -z "$all_tags" ]; then
                all_tags=$(crane ls "$base" 2>/dev/null)
              fi

              # Get latest and recent versions
              tag=$(echo "$all_tags" | tail -1)
              recent=$(echo "$all_tags" | tail -5 | tac | tr '\n' ' ')

              if [ -n "$tag" ]; then
                full="$base:$tag"
                echo "Recent versions: $recent" > "$logfile"
                echo "Selected: $tag" >> "$logfile"
                pull_oci_image "$full" "$logfile"
              else
                echo "Error: Could not find tags for $base" > "$logfile"
                exit 1
              fi
            ) &
            PIDS[$!]="upbound-$img"
          done
        fi

        # Extra OCI images (pulled with crane)
        if [ -n "${{ inputs.extra-oci-images }}" ]; then
          while read img; do
            img=$(echo "$img" | xargs)  # trim whitespace
            if [ -n "$img" ]; then
              name=$(echo "$img" | sed 's|.*/||' | sed 's/:/-/g')
              (pull_oci_image "$img" "$LOGDIR/oci-$name.log") &
              PIDS[$!]="oci-$name"
            fi
          done < <(echo "${{ inputs.extra-oci-images }}" | tr ',' '\n')
        fi

        # Extract and pull function/provider/configuration packages from upbound.yaml
        if [ "${{ inputs.from-upbound-yaml }}" = "true" ] && [ -f upbound.yaml ]; then
          echo "Found upbound.yaml, parsing dependencies..."

          # Pull functions (combine package + version, strip semver operators)
          echo "Parsing functions..."
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Function: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (pull_oci_image "$pkg" "$LOGDIR/function-$name.log") &
              PIDS[$!]="function-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Function") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          # Check if any provider-aws-* is used, if so pull provider-family-aws once
          echo "Parsing providers..."
          first_aws_pkg=$(yq -r '.spec.dependsOn[] | select(.kind == "Provider") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null | grep "provider-aws-" | head -1 || true)
          if [ -n "$first_aws_pkg" ]; then
            family_pkg=$(echo "$first_aws_pkg" | sed 's/provider-aws-[^:]*:/provider-family-aws:/')
            echo "  Provider (family): $family_pkg"
            name=$(echo "$family_pkg" | sed 's|.*/||' | sed 's/:/-/g')
            (pull_oci_image "$family_pkg" "$LOGDIR/provider-$name.log") &
            PIDS[$!]="provider-$name"
          fi

          # Pull providers (combine package + version, strip semver operators)
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Provider: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (pull_oci_image "$pkg" "$LOGDIR/provider-$name.log") &
              PIDS[$!]="provider-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Provider") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          # Pull configurations (combine package + version, strip semver operators)
          echo "Parsing configurations..."
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Configuration: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (pull_oci_image "$pkg" "$LOGDIR/configuration-$name.log") &
              PIDS[$!]="configuration-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Configuration") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          echo "Starting ${#PIDS[@]} background jobs..."
        fi

        # Wait for each process and track failures
        # Disable errexit temporarily for wait loop
        FAILED=()
        set +e
        for pid in "${!PIDS[@]}"; do
          if ! wait "$pid"; then
            FAILED+=("${PIDS[$pid]}")
          fi
        done
        set -e

        # Display organized logs
        echo ""
        echo "=== Pre-pull Results ==="
        shopt -s nullglob
        for logfile in "$LOGDIR"/*.log; do
          name=$(basename "$logfile" .log)
          echo ""
          echo "--- $name ---"
          cat "$logfile"
        done
        shopt -u nullglob

        # Show cache stats
        echo ""
        echo "=== Cache Stats ==="
        echo "Cache directory: $CACHE_DIR"
        if [ -d "$CACHE_DIR" ]; then
          echo "Cached images: $(ls -1 "$CACHE_DIR"/*.tar 2>/dev/null | wc -l || echo 0)"
          echo "Cache size: $(du -sh "$CACHE_DIR" 2>/dev/null | cut -f1 || echo "0")"
        fi

        # Report failures and exit with error if any
        if [ ${#FAILED[@]} -gt 0 ]; then
          echo ""
          echo "=== FAILED PROCESSES ==="
          for name in "${FAILED[@]}"; do
            echo ""
            echo "  FAILED: $name"
            logfile="$LOGDIR/$name.log"
            if [ -f "$logfile" ]; then
              echo "  Log output:"
              sed 's/^/    /' "$logfile"
            else
              echo "  (no log file found)"
            fi
          done
          echo ""
          echo "Pre-pull failed for ${#FAILED[@]} process(es)"
          rm -rf "$LOGDIR"
          exit 1
        fi

        # Cleanup logs
        rm -rf "$LOGDIR"

        echo ""
        echo "All images verified/pre-pulled successfully"
