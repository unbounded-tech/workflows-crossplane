name: 'Pre-pull OCI Images'
description: 'Pre-pull Docker and OCI images used by Crossplane/Upbound tooling'

inputs:
  kind-node:
    description: 'Pull kindest/node image for Kind clusters'
    required: false
    default: 'false'
  kind-node-version:
    description: 'Kind node version to pull'
    required: false
    default: 'v1.33.1'
  upbound-images:
    description: 'Pull internal Upbound CLI images (olareg, datamodel-code-generator, kcl, function-go-templating-base)'
    required: false
    default: 'true'
  from-upbound-yaml:
    description: 'Pull functions/providers/configurations from upbound.yaml'
    required: false
    default: 'true'
  extra-docker-images:
    description: 'Comma-separated list of additional Docker images to pull'
    required: false
    default: ''
  extra-oci-images:
    description: 'Comma-separated list of additional OCI images to pull with crane'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    - name: Install crane
      shell: bash
      run: |
        CRANE_VERSION="v0.20.2"
        curl -sL "https://github.com/google/go-containerregistry/releases/download/${CRANE_VERSION}/go-containerregistry_Linux_x86_64.tar.gz" | tar -xzf - crane
        sudo mv crane /usr/local/bin/

    - name: Pre-pull images
      shell: bash
      run: |
        set -euo pipefail

        # Error handler
        error_handler() {
          local line=$1
          local cmd=$2
          echo ""
          echo "ERROR: Command failed at line $line: $cmd"
          echo ""
        }
        trap 'error_handler ${LINENO} "$BASH_COMMAND"' ERR

        echo "Pre-pulling Docker/OCI images in parallel..."

        # Create temp directory for logs
        LOGDIR=$(mktemp -d)

        # Track PIDs and their descriptions
        declare -A PIDS

        # Kind node (Docker image)
        if [ "${{ inputs.kind-node }}" = "true" ]; then
          docker pull kindest/node:${{ inputs.kind-node-version }} > "$LOGDIR/docker-kindest-node.log" 2>&1 &
          PIDS[$!]="docker-kindest-node"
        fi

        # Extra Docker images
        if [ -n "${{ inputs.extra-docker-images }}" ]; then
          while read img; do
            img=$(echo "$img" | xargs)  # trim whitespace
            if [ -n "$img" ]; then
              name=$(echo "$img" | sed 's|.*/||' | sed 's/:/-/g')
              docker pull "$img" > "$LOGDIR/docker-$name.log" 2>&1 &
              PIDS[$!]="docker-$name"
            fi
          done < <(echo "${{ inputs.extra-docker-images }}" | tr ',' '\n')
        fi

        # Upbound internal images used by `up` CLI (from xpkg.upbound.io)
        # Dynamically look up latest versions
        if [ "${{ inputs.upbound-images }}" = "true" ]; then
          for img in olareg datamodel-code-generator kcl function-go-templating-base; do
            (
              base="xpkg.upbound.io/upbound/$img"
              # Get all semver tags sorted
              all_tags=$(crane ls "$base" 2>/dev/null | grep -E '^v[0-9]' | sort -V)
              if [ -z "$all_tags" ]; then
                all_tags=$(crane ls "$base" 2>/dev/null)
              fi

              # Get latest and recent versions
              tag=$(echo "$all_tags" | tail -1)
              recent=$(echo "$all_tags" | tail -5 | tac | tr '\n' ' ')

              if [ -n "$tag" ]; then
                full="$base:$tag"
                echo "Recent versions: $recent" > "$LOGDIR/upbound-$img.log"
                echo "Selected: $tag" >> "$LOGDIR/upbound-$img.log"
                crane digest "$full" >> "$LOGDIR/upbound-$img.log" 2>&1
                echo "Verified: $full" >> "$LOGDIR/upbound-$img.log"
              else
                echo "Error: Could not find tags for $base" > "$LOGDIR/upbound-$img.log"
                exit 1
              fi
            ) &
            PIDS[$!]="upbound-$img"
          done
        fi

        # Extra OCI images (pulled with crane)
        if [ -n "${{ inputs.extra-oci-images }}" ]; then
          while read img; do
            img=$(echo "$img" | xargs)  # trim whitespace
            if [ -n "$img" ]; then
              name=$(echo "$img" | sed 's|.*/||' | sed 's/:/-/g')
              (crane digest "$img" > "$LOGDIR/oci-$name.log" 2>&1 && echo "Verified: $img" >> "$LOGDIR/oci-$name.log") &
              PIDS[$!]="oci-$name"
            fi
          done < <(echo "${{ inputs.extra-oci-images }}" | tr ',' '\n')
        fi

        # Extract and pull function/provider/configuration packages from upbound.yaml
        if [ "${{ inputs.from-upbound-yaml }}" = "true" ] && [ -f upbound.yaml ]; then
          echo "Found upbound.yaml, parsing dependencies..."

          # Pull functions (combine package + version, strip semver operators)
          echo "Parsing functions..."
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Function: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (crane digest "$pkg" > "$LOGDIR/function-$name.log" 2>&1 && echo "Verified: $pkg" >> "$LOGDIR/function-$name.log") &
              PIDS[$!]="function-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Function") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          # Check if any provider-aws-* is used, if so pull provider-family-aws once
          echo "Parsing providers..."
          first_aws_pkg=$(yq -r '.spec.dependsOn[] | select(.kind == "Provider") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null | grep "provider-aws-" | head -1 || true)
          if [ -n "$first_aws_pkg" ]; then
            family_pkg=$(echo "$first_aws_pkg" | sed 's/provider-aws-[^:]*:/provider-family-aws:/')
            echo "  Provider (family): $family_pkg"
            name=$(echo "$family_pkg" | sed 's|.*/||' | sed 's/:/-/g')
            (crane digest "$family_pkg" > "$LOGDIR/provider-$name.log" 2>&1 && echo "Verified: $family_pkg" >> "$LOGDIR/provider-$name.log") &
            PIDS[$!]="provider-$name"
          fi

          # Pull providers (combine package + version, strip semver operators)
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Provider: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (crane digest "$pkg" > "$LOGDIR/provider-$name.log" 2>&1 && echo "Verified: $pkg" >> "$LOGDIR/provider-$name.log") &
              PIDS[$!]="provider-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Provider") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          # Pull configurations (combine package + version, strip semver operators)
          echo "Parsing configurations..."
          while read pkg; do
            if [ -n "$pkg" ]; then
              echo "  Configuration: $pkg"
              name=$(echo "$pkg" | sed 's|.*/||' | sed 's/:/-/g')
              (crane digest "$pkg" > "$LOGDIR/configuration-$name.log" 2>&1 && echo "Verified: $pkg" >> "$LOGDIR/configuration-$name.log") &
              PIDS[$!]="configuration-$name"
            fi
          done < <(yq -r '.spec.dependsOn[] | select(.kind == "Configuration") | .package + ":" + (.version | sub("^[>=<^~]+"; ""))' upbound.yaml 2>/dev/null)

          echo "Starting ${#PIDS[@]} background jobs..."
        fi

        # Wait for each process and track failures
        # Disable errexit temporarily for wait loop
        FAILED=()
        set +e
        for pid in "${!PIDS[@]}"; do
          if ! wait "$pid"; then
            FAILED+=("${PIDS[$pid]}")
          fi
        done
        set -e

        # Display organized logs
        echo ""
        echo "=== Pre-pull Results ==="
        shopt -s nullglob
        for logfile in "$LOGDIR"/*.log; do
          name=$(basename "$logfile" .log)
          echo ""
          echo "--- $name ---"
          cat "$logfile"
        done
        shopt -u nullglob

        # Report failures and exit with error if any
        if [ ${#FAILED[@]} -gt 0 ]; then
          echo ""
          echo "=== FAILED PROCESSES ==="
          for name in "${FAILED[@]}"; do
            echo ""
            echo "  FAILED: $name"
            logfile="$LOGDIR/$name.log"
            if [ -f "$logfile" ]; then
              echo "  Log output:"
              sed 's/^/    /' "$logfile"
            else
              echo "  (no log file found)"
            fi
          done
          echo ""
          echo "Pre-pull failed for ${#FAILED[@]} process(es)"
          rm -rf "$LOGDIR"
          exit 1
        fi

        # Cleanup
        rm -rf "$LOGDIR"

        echo ""
        echo "All images verified/pre-pulled successfully"
